## Основы

#### Что делает оператор `===`?

1. Сравнивает по ссылке, а не по значению.
2. Сравнивает без приведения типа.
3. Нет такого оператора.

<details>
  <summary>Ответ</summary>

❌ Сравнивает по ссылке, а не по значению.

✅ Сравнивает без приведения типа.

❌ Нет такого оператора.

</details>

#### Какие конструкции для циклов есть в javascript?

1. Только две: for и while.
2. Только одна: for.
3. Три: for, while и do...while.

<details>
  <summary>Ответ</summary>

❌ Только две: for и while.

❌ Только одна: for.

✅ Три: for, while и do...while.

for — классический цикл с инициализацией, условием и инкрементом.

while — цикл, который выполняется, пока условие истинно.

do...while — похоже на while, но проверка условия выполняется после тела цикла, что гарантирует его выполнение хотя бы один раз.

</details>

#### Какое из этих слов не имеет специального использования в JavaScript, никак не упомянуто в стандарте?

1. this
2. instanceof
3. constructor
4. parent
5. new
6. Все имеют специальное использование.

<details>
  <summary>Ответ</summary>

❌ this

❌ instanceof

❌ constructor

✅ parent

❌ new

❌ Все имеют специальное использование.

</details>

#### Сколько параметров можно передать функции ?

1. Ровно столько, сколько указано в определении функции.
2. Сколько указано в определении функции или меньше.
3. Сколько указано в определении функции или больше.
4. Любое количество.

<details>
  <summary>Ответ</summary>
❌ Ровно столько, сколько указано в определении функции.

❌ Сколько указано в определении функции или меньше.

❌ Сколько указано в определении функции или больше.

✅ Любое количество. В JavaScript функции могут принимать любое количество аргументов, независимо от того, сколько параметров указано в их определении. Если передать больше аргументов, чем указано, дополнительные аргументы будут доступны в массиве arguments, а если меньше — неиспользуемые параметры будут просто undefined. Это создает сложности при разработке, поскольку разработчик должен быть внимателен к количеству и типам передаваемых аргументов.

Вот пример:

```
function print(x, y) {
  console.log(x, y);
  console.log(arguments);
}

print(10, 20, 30);
```

Результат:

```
10 20
[Arguments] { '0': 10, '1': 20, '2': 30 }
```

</details>

### Что выведет этот код?

```
console.log(2 && 1 && null && 0 && undefined);
```

<details>
  <summary>Ответ</summary>

Оператор `&&` возвращает последние истинное значение или первое ложное, если истинных не было. Поэтому `null`.

</details>

---

```
let a = (1,5 - 1) * 2;

console.log(a);
```

<details>
  <summary>Ответ</summary>

В этом коде `let a = (1,5 - 1) * 2;` используется оператор запятая `,` в выражении. Оператор запятая возвращает последнее значение в списке.

Таким образом, `(1, 5 - 1)` вычисляется как:

1. Сначала выполняется `1` (результат игнорируется),
2. Затем выполняется `5 - 1`, что равно `4`.
   После этого, в результате будет `a = 4 * 2;`, что равно `8`.

Поэтому код выведет `8`.

</details>

---

```
for (var i = 0; i < 10; i++) {}

console.log(i)
```

<details>
  <summary>Ответ</summary>
 
Переменная `i` объявлена с помощью `var`, что делает ее доступной не только внутри цикла, но и за его пределами. В итоге, когда вы выполните `console.log(i)` после цикла, в консоли будет выведено `10`, так как цикл завершился, и значение `i` инкрементировалось до 10.

Это связано с тем, что `var` имеет функциональную область видимости (или глобальную, если объявлена вне функции), а не блочную область видимости, как у `let` и `const`.

</details>

---

```
"use strict"

console.log(typeof null)
```

<details>
  <summary>Ответ</summary>
 
`object` - ведь это давняя ошибка языка. огромное количество пакетов, решений и библиотек написано с учетом этой ошибки. Так просто ее не исправить.

</details>

---

---

---

## Числа

#### Какие вызовы parseInt возвратят число?

- parseInt("1px")
- parseInt("-1.2")
- parseInt("0 минут")
- parseInt("$1.2")

<details>
  <summary>Ответ</summary>

✅ parseInt("1px"): Вернет `1`

✅ parseInt("-1.2"): Вернет `-1`

✅ parseInt("0 минут"): Вернет `0`

❌ `parseInt("$1.2")`: вернет `NaN`. Символ `$` не является цифрой, поэтому число не извлекается.

</details>

#### Какая арифметическая операция приводит к ошибке в javascript?

1. Деление на ноль.
2. Умножение числа на строку.
3. Корень из отрицательного числа.
4. Никакая из вышеперечисленных.

<details>
  <summary>Ответ</summary>

❌ Деление на ноль: При делении на ноль результат будет `Infinity` или `-Infinity`, а не ошибка. Например, `5 / 0` вернёт `Infinity`.

❌ Умножение числа на строку. Результатом будет `NaN` (Not-a-Number), но это не ошибка.

❌ Корень из отрицательного числа. При выполнении этого операции JavaScript вернёт `NaN`, но тоже без ошибки.

✅ Никакая из вышеперечисленных.

</details>

---

### Что выведет этот код?

```
let x = 5;
console.log(x++);
```

<details>
  <summary>Ответ</summary>

Оператор постфиксного инкремента `++` сначала возвращает текущее значение переменной `x`, а затем увеличивает ее на `1`. Таким образом, в `console.log` передается `5`, а само значение `x` после этого станет `6`.

</details>

---

```
console.log(20e-1["toString"](2))
```

<details>
  <summary>Ответ</summary>

`20e-1` — это научная нотация, которая означает 20 × 10<sup>-1</sup> = 2.
Затем `2['toString'](2)` вызывает метод `toString` для числа `2`, преобразуя его в строку в двоичной системе счисления. В двоичной системе число `2` представляется как `10`.
Поэтому результат — `10`.

</details>

---

```
console.log(+"Infinity");
```

<details>
  <summary>Ответ</summary>

Оператор `+` в данном контексте используется для явного приведения типа (преобразования). Он пытается преобразовать строку `"Infinity"` в число, и результатом будет число, представляющее бесконечность (в JavaScript это именно `Infinity`).

</details>

---

---

---

## Строки

### Что выведет этот код?

```
console.log( "1"[0] );
```

<details>
  <summary>Ответ</summary>
  
  Выведет `"1"`.
  
</details>

---

---

---

## Массивы

#### Какой код корректно найдёт максимальное значение в непустом массиве arr?

- arr.reduce(function(prev, item) { return Math.max(prev, item) })
- Math.max.apply(null, arr)
- Math.max(arr)
- arr.findMax()

<details>
  <summary>Ответ</summary>

✅ arr.reduce(function(prev, item) { return Math.max(prev, item) })

Этот код верный. Он проходит по массиву, сравнивая элементы и возвращая максимальное значение.

✅ Math.max.apply(null, arr)

Это также корректный способ. Он использует метод `Math.max` с `apply`, что позволяет передать элементы массива как отдельные аргументы.

❌ Math.max(arr)

Этот код некорректен, так как `Math.max` не принимает массив в качестве аргумента. Это вызовет ошибку.

❌ arr.findMax()

Этот вызов не является стандартным методом для массива в JavaScript и вызовет ошибку, если метод `findMax` не определён заранее.

</details>

#### Выберите правильные варианты объявления массива, то есть такие, в результате которых мы получаем массив из двух строк "Стас" и "Колько".

- new Array.prototype.constructor("Стас", "Колько")
- new Array("Стас", "Колько")
- Array("Стас", "Колько")
- ["Стас", "Колько"]
- "Стас"..."Колько"
- Все варианты правильные.

<details>
  <summary>Ответ</summary>
 
✅ new Array.prototype.constructor("Стас", "Колько")

✅ new Array("Стас", "Колько")

✅ Array("Стас", "Колько")

✅ ["Стас", "Колько"]

❌ "Стас".."Колько": Это синтаксически неверно. В JavaScript два точек подряд интерпретируются как попытка вызывать метод на числе или как ошибочный синтаксис.

❌ Все варианты правильные

</details>

---

### Что выведет этот код?

```
[].push(1, 2).unshift(3).join()
```

<details>
  <summary>Ответ</summary>
  
  Метод `push` добавляет в массив 1 и 2, а затем возвращает новую длину массива (число). 
  Поэтому попытка применить `unshift` к этому числу приводит к ошибке, так как `unshift` нельзя вызвать на числовом значении.
  
</details>

---

---

---

## Объекты

### Что выведет этот код?

```
let obj = {
 "100": 5,
 100: 10
};

console.log(obj["100"] + obj[100]);
```

<details>
  <summary>Ответ</summary>
 
  Ключи в объекте JavaScript приводятся к строкам, поэтому и 100, и "100" ссылаются на одно и то же свойство. При создании объекта obj значение 5 перезаписывается на 10, и выражение obj["100"] + obj[100] равно `20`.
</details>

---

```
function F() {}

console.log(F.prototype);
```

<details>
  <summary>Ответ</summary>

Когда вы объявляете функцию в JavaScript, автоматически создается объект, называемый прототипом этой функции, который можно использовать для добавления свойств и методов, доступных всем экземплярам, созданным с помощью этой функции (например, через оператор `new`). `F.prototype` - это обычный объект. Поэтому выведет `{}`.

</details>

---

---

---

## Функции

### Что выведет этот код?

```
function MyArray() { }
MyArray.prototype = [];

let arr = new MyArray();
arr.push(1, 2, 3, 4, 5);
console.log(arr.length);
```

<details>
  <summary>Ответ</summary>
 
  Выведет `5`.
</details>

---
